<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>FILE_02: THE FORTRESS</title>
    <style>
        body { margin: 0; background: #110000; color: #FF3366; font-family: monospace; overflow: hidden; display: flex; flex-direction: column; align-items: center; justify-content: center; height: 100vh; }
        canvas { border: 2px solid #FF3366; background: #0a0000; }
        #ui { position: absolute; top: 20px; text-align: center; width: 100%; pointer-events: none; }
        h1 { margin: 0; text-shadow: 0 0 10px #FF3366; }
        p { color: #aaa; background: rgba(0,0,0,0.8); display: inline-block; padding: 5px; }
        #back-btn { position: absolute; bottom: 20px; text-decoration: none; color: #fff; border: 1px solid #fff; padding: 10px 20px; display: none; pointer-events: auto; }
    </style>
</head>
<body>
    <div id="ui">
        <h1>THE FORTRESS</h1>
        <p>You built walls to survive. Deflect the negativity.<br>[Move Mouse/Touch to Rotate Shield]</p>
        <div id="hp">INTEGRITY: 100%</div>
    </div>
    <canvas id="c"></canvas>
    <a href="index.html" id="back-btn">THREAT NEUTRALIZED. RETURN.</a>

    <script>
        const c = document.getElementById('c');
        const ctx = c.getContext('2d');
        let w, h;
        
        let angle = 0;
        let hp = 100;
        let threats = [];
        let score = 0;
        let state = 'playing'; // playing, win, over

        const resize = () => {
            w = c.width = window.innerWidth > 800 ? 800 : window.innerWidth - 40;
            h = c.height = 600;
        };

        const spawnThreat = () => {
            if(state !== 'playing') return;
            const a = Math.random() * Math.PI * 2;
            const r = 400;
            threats.push({
                x: w/2 + Math.cos(a) * r,
                y: h/2 + Math.sin(a) * r,
                vx: -Math.cos(a) * 3,
                vy: -Math.sin(a) * 3,
                text: ["FAKE", "EXCLUDED", "RUDE", "ALONE"][Math.floor(Math.random()*4)],
                active: true
            });
            if(score < 10) setTimeout(spawnThreat, 1000);
        };

        // Audio
        const audioCtx = new (window.AudioContext || window.webkitAudioContext)();
        const sfx = (freq) => {
            if(audioCtx.state === 'suspended') audioCtx.resume();
            const o = audioCtx.createOscillator();
            const g = audioCtx.createGain();
            o.type = 'sawtooth';
            o.frequency.setValueAtTime(freq, audioCtx.currentTime);
            o.frequency.exponentialRampToValueAtTime(freq/2, audioCtx.currentTime + 0.1);
            g.gain.value = 0.1;
            g.gain.linearRampToValueAtTime(0, audioCtx.currentTime + 0.1);
            o.connect(g); g.connect(audioCtx.destination);
            o.start(); o.stop(audioCtx.currentTime + 0.1);
        };

        const update = () => {
            if(state !== 'playing') return;

            threats.forEach(t => {
                if(!t.active) return;
                t.x += t.vx;
                t.y += t.vy;

                const dx = t.x - w/2;
                const dy = t.y - h/2;
                const dist = Math.sqrt(dx*dx + dy*dy);

                // Shield Hit Check (Shield is approx +/- 45 deg from mouse angle)
                if(dist < 60 && dist > 40) {
                    const threatAngle = Math.atan2(dy, dx);
                    let diff = threatAngle - angle;
                    while(diff < -Math.PI) diff += Math.PI*2;
                    while(diff > Math.PI) diff -= Math.PI*2;

                    if(Math.abs(diff) < 1) { // Blocked
                        t.active = false;
                        t.vx *= -1.5; t.vy *= -1.5; // Bounce visuals
                        sfx(440);
                        score++;
                        if(score >= 10) win();
                    }
                }

                // Core Hit
                if(dist < 20) {
                    t.active = false;
                    hp -= 20;
                    document.getElementById('hp').innerText = `INTEGRITY: ${hp}%`;
                    sfx(100);
                    c.style.transform = `translate(${Math.random()*10-5}px, ${Math.random()*10-5}px)`;
                    setTimeout(() => c.style.transform = 'none', 50);
                    if(hp <= 0) {
                        state = 'over';
                        document.querySelector('p').innerText = "Don't let them break you. Refresh to try again.";
                    }
                }
            });
        };

        const win = () => {
            state = 'win';
            threats = [];
            document.querySelector('h1').innerText = "SHIELD NOT REQUIRED";
            document.querySelector('p').innerText = "You realized: Your value cannot be damaged by words. The 'Tough Cookie' shell protected you, but your core is diamond.";
            document.getElementById('back-btn').style.display = 'block';
        };

        const draw = () => {
            ctx.fillStyle = 'rgba(16,0,0,0.3)';
            ctx.fillRect(0,0,w,h);

            const cx = w/2, cy = h/2;

            // Draw Core (Anushri)
            ctx.beginPath();
            ctx.arc(cx, cy, 15, 0, Math.PI*2);
            ctx.fillStyle = '#fff';
            ctx.shadowBlur = 20; ctx.shadowColor = '#fff';
            ctx.fill();
            ctx.shadowBlur = 0;

            // Draw Shield
            ctx.beginPath();
            ctx.arc(cx, cy, 50, angle - 1, angle + 1);
            ctx.strokeStyle = '#FF3366';
            ctx.lineWidth = 5;
            ctx.stroke();

            // Draw Threats
            ctx.font = '12px monospace';
            ctx.textAlign = 'center';
            threats.forEach(t => {
                if(!t.active) return;
                ctx.fillStyle = '#f00';
                ctx.fillText(t.text, t.x, t.y);
            });

            requestAnimationFrame(draw);
        };

        const loop = () => {
            update();
            draw();
            if(state === 'playing') requestAnimationFrame(loop);
        };

        c.addEventListener('mousemove', e => {
            const rect = c.getBoundingClientRect();
            const dx = e.clientX - rect.left - w/2;
            const dy = e.clientY - rect.top - h/2;
            angle = Math.atan2(dy, dx);
        });
        
        c.addEventListener('touchmove', e => {
            e.preventDefault();
            const rect = c.getBoundingClientRect();
            const dx = e.touches[0].clientX - rect.left - w/2;
            const dy = e.touches[0].clientY - rect.top - h/2;
            angle = Math.atan2(dy, dx);
        });

        window.addEventListener('resize', resize);
        resize();
        spawnThreat();
        draw();
        setInterval(update, 16);

    </script>
</body>
</html>
