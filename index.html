<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>ANUSHRI_ARCHIVE_REMASTERED</title>
    <style>
        /* --- TYPOGRAPHY --- */
        @import url('https://fonts.googleapis.com/css2?family=Space+Mono:ital,wght@0,400;0,700;1,400&family=VT323&display=swap');

        :root {
            --phosphor-main: #33ff00;
            --phosphor-dim: #1a8000;
            --phosphor-bloom: #ccffb3;
            --alert: #ff3333;
            --gold: #ffcc00;
            --chassis: #111;
            --chassis-light: #222;
            --bg-grain: #050505;
        }

        /* --- GLOBAL RESET & AESTHETICS --- */
        * { box-sizing: border-box; user-select: none; -webkit-tap-highlight-color: transparent; cursor: crosshair; }
        
        body {
            background-color: var(--bg-grain);
            margin: 0;
            height: 100vh;
            overflow: hidden;
            font-family: 'Space Mono', monospace;
            color: #ccc;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        /* Film Grain Overlay */
        body::after {
            content: "";
            position: absolute; inset: 0;
            background-image: url("data:image/svg+xml,%3Csvg viewBox='0 0 200 200' xmlns='http://www.w3.org/2000/svg'%3E%3Cfilter id='noiseFilter'%3E%3CfeTurbulence type='fractalNoise' baseFrequency='0.85' numOctaves='3' stitchTiles='stitch'/%3E%3C/filter%3E%3Crect width='100%25' height='100%25' filter='url(%23noiseFilter)' opacity='0.08'/%3E%3C/svg%3E");
            pointer-events: none;
            z-index: 9999;
        }

        /* --- LAYOUT GRID --- */
        #workspace {
            display: grid;
            grid-template-columns: 1fr 320px;
            grid-template-rows: 1fr 160px;
            gap: 24px;
            width: 96vw;
            height: 92vh;
            max-width: 1400px;
            position: relative;
        }

        /* --- COMPONENT: THE MONITOR (TV) --- */
        .monitor-casing {
            grid-column: 1;
            grid-row: 1 / span 2;
            background: #1a1a1a;
            border-radius: 32px;
            padding: 32px;
            box-shadow: 
                inset 0 0 80px #000,
                0 20px 50px rgba(0,0,0,0.8),
                0 0 0 4px #2a2a2a;
            position: relative;
            display: flex;
            flex-direction: column;
        }

        .screen-bezel {
            flex: 1;
            background: #000;
            border-radius: 60% 60% 60% 60% / 10% 10% 10% 10%; /* Subtle CRT curve */
            border-radius: 16px; /* Modern fallback */
            position: relative;
            overflow: hidden;
            border: 8px solid #0f0f0f;
            box-shadow: inset 0 0 20px rgba(0,0,0,1);
        }

        canvas#crt-canvas {
            display: block;
            width: 100%;
            height: 100%;
            filter: contrast(1.1) brightness(1.2) saturate(1.1);
        }

        /* CRT Effects Layer */
        .crt-overlay {
            position: absolute; inset: 0; pointer-events: none;
            background: 
                linear-gradient(rgba(18, 16, 16, 0) 50%, rgba(0, 0, 0, 0.25) 50%), 
                linear-gradient(90deg, rgba(255, 0, 0, 0.06), rgba(0, 255, 0, 0.02), rgba(0, 0, 255, 0.06));
            background-size: 100% 2px, 3px 100%;
            mix-blend-mode: overlay;
        }
        
        .screen-glare {
            position: absolute; inset: 0; pointer-events: none;
            background: radial-gradient(circle at 30% 30%, rgba(255,255,255,0.05), transparent 40%);
        }

        /* --- COMPONENT: TAPE RACK --- */
        .tape-rack {
            grid-column: 2;
            grid-row: 1;
            background: #111;
            border: 1px solid #333;
            border-radius: 8px;
            padding: 20px;
            display: flex;
            flex-direction: column;
            gap: 16px;
            box-shadow: inset 0 0 30px #000;
        }

        .rack-header {
            color: #555;
            font-size: 0.8rem;
            letter-spacing: 2px;
            text-align: center;
            border-bottom: 1px solid #222;
            padding-bottom: 10px;
            margin-bottom: 10px;
        }

        /* --- COMPONENT: PHYSICAL TAPE --- */
        .tape-obj {
            width: 100%;
            height: 100px;
            background: #222;
            border-radius: 6px;
            border: 1px solid #333;
            position: relative;
            cursor: grab;
            touch-action: none; /* Critical for custom drag */
            transition: box-shadow 0.2s;
            box-shadow: 2px 4px 10px #000;
        }

        .tape-obj:hover {
            border-color: #555;
            box-shadow: 4px 8px 15px rgba(0,0,0,0.5);
        }

        .tape-obj.dragging {
            cursor: grabbing;
            z-index: 1000;
            box-shadow: 0 20px 40px rgba(0,0,0,0.8);
            transform: scale(1.05);
        }
        
        .tape-obj.in-machine {
            opacity: 0;
            pointer-events: none;
            transition: opacity 0.5s;
        }

        /* Tape Details */
        .tape-window {
            position: absolute; top: 15px; left: 10%; width: 80%; height: 25px;
            background: #000; border-radius: 2px; border: 1px solid #333;
            display: flex; justify-content: space-between; padding: 0 15%; align-items: center;
        }
        .tape-spool { width: 20px; height: 20px; border-radius: 50%; border: 2px solid #fff; opacity: 0.2; }
        
        .tape-label {
            position: absolute; bottom: 15px; left: 5%; width: 90%;
            background: #f0f0f0; color: #111;
            font-family: 'Space Mono', monospace; font-weight: 700; font-size: 0.8rem;
            padding: 4px 8px; text-align: center;
            border-radius: 2px;
            transform: rotate(-0.5deg);
            box-shadow: 0 1px 2px rgba(0,0,0,0.3);
        }

        /* --- COMPONENT: VCR DECK --- */
        .vcr-deck {
            grid-column: 2;
            grid-row: 2;
            background: linear-gradient(to bottom, #222, #111);
            border-radius: 8px;
            border: 1px solid #333;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            position: relative;
            box-shadow: 0 10px 30px rgba(0,0,0,0.5);
        }

        .slot-housing {
            width: 85%; height: 40px;
            background: #000;
            border: 2px solid #333;
            border-radius: 4px;
            position: relative;
            overflow: hidden;
            transition: all 0.3s;
        }

        .slot-housing.active {
            border-color: var(--phosphor-main);
            box-shadow: 0 0 15px var(--phosphor-dim);
        }

        .slot-door {
            width: 100%; height: 100%;
            background: #1a1a1a;
            transform-origin: top;
            transition: transform 0.2s;
            border-bottom: 1px solid #333;
        }

        .slot-housing.open .slot-door { transform: rotateX(-90deg); }

        .vcr-controls {
            margin-top: 20px;
            display: flex;
            gap: 20px;
            width: 85%;
            justify-content: space-between;
            align-items: center;
        }

        .led-indicator {
            width: 8px; height: 8px; background: #300; border-radius: 50%;
            box-shadow: inset 0 0 2px #000;
            transition: background 0.2s;
        }
        .led-indicator.on { background: #f00; box-shadow: 0 0 8px #f00; }
        
        .counter-display {
            font-family: 'VT323', monospace;
            font-size: 1.5rem;
            color: var(--phosphor-main);
            text-shadow: 0 0 5px var(--phosphor-dim);
            background: #000;
            padding: 2px 8px;
            border-radius: 2px;
        }

        .btn-eject {
            background: #333; color: #fff; border: none;
            padding: 6px 12px; font-family: 'Space Mono'; font-size: 0.7rem;
            cursor: pointer; border-radius: 2px;
            transition: background 0.2s;
        }
        .btn-eject:hover { background: #444; }

        /* --- UI OVERLAY (BIOS) --- */
        #bios-screen {
            position: fixed; inset: 0; background: #000; z-index: 10000;
            display: flex; flex-direction: column; align-items: center; justify-content: center;
            color: var(--phosphor-main);
            font-family: 'VT323';
        }
        
        .bios-text { font-size: 1.5rem; text-shadow: 0 0 10px var(--phosphor-dim); margin-bottom: 20px; }
        .blink { animation: blink 1s infinite; }
        
        @keyframes blink { 50% { opacity: 0; } }

        @media (max-width: 900px) {
            #workspace { grid-template-columns: 1fr; grid-template-rows: 1fr 120px 180px; gap: 10px; width: 100vw; height: 100vh; padding: 10px; }
            .monitor-casing { grid-column: 1; grid-row: 1; padding: 10px; border-radius: 10px; }
            .vcr-deck { grid-column: 1; grid-row: 2; }
            .tape-rack { grid-column: 1; grid-row: 3; flex-direction: row; overflow-x: auto; padding: 10px; align-items: center; }
            .tape-obj { min-width: 140px; height: 90px; }
        }
    </style>
</head>
<body>

    <!-- BIOS BOOT SCREEN -->
    <div id="bios-screen">
        <div class="bios-text">ANUSHRI_ARCHIVE.SYS LOADING...</div>
        <div class="bios-text">MEM: 64KB OK</div>
        <br>
        <div class="bios-text blink">[ CLICK TO INITIALIZE SYSTEM ]</div>
    </div>

    <!-- MAIN WORKSPACE -->
    <div id="workspace">
        
        <!-- TV -->
        <div class="monitor-casing">
            <div class="screen-bezel">
                <canvas id="crt-canvas"></canvas>
                <div class="crt-overlay"></div>
                <div class="screen-glare"></div>
            </div>
        </div>

        <!-- TAPE RACK -->
        <div class="tape-rack" id="rack">
            <div class="rack-header">ARCHIVE STORAGE</div>
            <!-- Tapes generated via JS -->
        </div>

        <!-- VCR -->
        <div class="vcr-deck" id="vcr-deck">
            <div class="slot-housing" id="slot">
                <div class="slot-door"></div>
            </div>
            
            <div class="vcr-controls">
                <div style="display:flex; align-items:center; gap:8px;">
                    <div class="led-indicator" id="pwr-led"></div>
                    <span style="font-size:0.7rem; color:#555">PWR</span>
                </div>
                
                <div class="counter-display" id="counter">00:00:00</div>
                
                <button class="btn-eject" id="eject-btn">EJECT</button>
            </div>
        </div>

    </div>

<script>
/**
 * ANUSHRI ARCHIVE: REMASTERED
 * A high-fidelity "analog horror" style interactive fiction.
 */

// --- 1. CORE UTILS & MATH ---
const MathUtils = {
    lerp: (start, end, amt) => (1 - amt) * start + amt * end,
    dist: (x1, y1, x2, y2) => Math.sqrt((x2 - x1) ** 2 + (y2 - y1) ** 2),
    clamp: (val, min, max) => Math.min(Math.max(val, min), max)
};

// --- 2. AUDIO CONTROLLER (Web Audio API) ---
const AudioEngine = {
    ctx: null,
    master: null,
    musicNodes: [],
    
    init() {
        if(this.ctx) return;
        this.ctx = new (window.AudioContext || window.webkitAudioContext)();
        this.master = this.ctx.createGain();
        this.master.gain.value = 0.4;
        this.master.connect(this.ctx.destination);
    },

    playTone(freq, type='sine', dur=0.1, vol=0.1) {
        if(!this.ctx) return;
        const osc = this.ctx.createOscillator();
        const gain = this.ctx.createGain();
        osc.type = type;
        osc.frequency.setValueAtTime(freq, this.ctx.currentTime);
        gain.gain.setValueAtTime(vol, this.ctx.currentTime);
        gain.gain.exponentialRampToValueAtTime(0.001, this.ctx.currentTime + dur);
        osc.connect(gain);
        gain.connect(this.master);
        osc.start();
        osc.stop(this.ctx.currentTime + dur);
    },

    playNoise(dur=0.2, type='white', vol=0.1) {
        if(!this.ctx) return;
        const size = this.ctx.sampleRate * dur;
        const buf = this.ctx.createBuffer(1, size, this.ctx.sampleRate);
        const data = buf.getChannelData(0);
        for(let i=0; i<size; i++) data[i] = Math.random() * 2 - 1;
        
        const src = this.ctx.createBufferSource();
        src.buffer = buf;
        const gain = this.ctx.createGain();
        gain.gain.value = vol;
        
        // Simple Lowpass for "Brown" noise feel
        const filter = this.ctx.createBiquadFilter();
        filter.type = 'lowpass';
        filter.frequency.value = type === 'brown' ? 400 : 3000;
        
        src.connect(filter);
        filter.connect(gain);
        gain.connect(this.master);
        src.start();
    },

    playClunk() {
        this.playNoise(0.3, 'brown', 0.5);
        this.playTone(60, 'square', 0.2, 0.4);
        setTimeout(() => this.playTone(40, 'sawtooth', 0.4, 0.3), 100);
    },

    // Procedural Music Engine
    startSoundtrack(theme) {
        this.stopMusic();
        
        const now = this.ctx.currentTime;
        
        if(theme === 'hallway') {
            // Sad, slow arpeggio
            const notes = [220, 261, 329, 392]; // Am7
            this.musicLoop = setInterval(() => {
                const n = notes[Math.floor(Math.random() * notes.length)];
                this.playTone(n, 'sine', 2.0, 0.05);
                this.playTone(n/2, 'triangle', 2.5, 0.02); // Bass
            }, 2500);
        } else if (theme === 'panic') {
            // Fast, dissonant
            this.musicLoop = setInterval(() => {
                const n = 100 + Math.random() * 50;
                this.playTone(n, 'sawtooth', 0.1, 0.05);
                if(Math.random()>0.7) this.playNoise(0.05, 'white', 0.1);
            }, 150);
        } else if (theme === 'void') {
            // Drone
            const osc = this.ctx.createOscillator();
            const g = this.ctx.createGain();
            osc.frequency.value = 55;
            g.gain.value = 0.05;
            osc.connect(g); g.connect(this.master);
            osc.start();
            this.musicNodes.push(osc);
        } else if (theme === 'hope') {
            // Major chords
            const notes = [261, 329, 392, 523]; // C Major
            this.musicLoop = setInterval(() => {
                notes.forEach((n,i) => {
                    setTimeout(() => this.playTone(n, 'sine', 1.5, 0.05), i*200);
                });
            }, 4000);
        }
    },

    stopMusic() {
        if(this.musicLoop) clearInterval(this.musicLoop);
        this.musicNodes.forEach(n => n.stop());
        this.musicNodes = [];
    }
};

// --- 3. PHYSICS & INPUT CONTROLLER (Custom Drag) ---
const Input = {
    x: 0, y: 0,
    isDown: false,
    dragTarget: null,
    dragOffset: { x:0, y:0 },
    
    init() {
        window.addEventListener('mousedown', e => this.down(e));
        window.addEventListener('mousemove', e => this.move(e));
        window.addEventListener('mouseup', e => this.up(e));
        
        window.addEventListener('touchstart', e => this.down(e.touches[0]));
        window.addEventListener('touchmove', e => this.move(e.touches[0]));
        window.addEventListener('touchend', e => this.up(e));
    },

    down(e) {
        this.isDown = true;
        this.x = e.clientX;
        this.y = e.clientY;
        
        // Check for tape intersection
        const tapes = document.querySelectorAll('.tape-obj');
        tapes.forEach(tape => {
            const rect = tape.getBoundingClientRect();
            if(this.x >= rect.left && this.x <= rect.right &&
               this.y >= rect.top && this.y <= rect.bottom && 
               !tape.classList.contains('in-machine')) {
                
                this.dragTarget = tape;
                this.dragOffset.x = this.x - rect.left;
                this.dragOffset.y = this.y - rect.top;
                
                // Lift
                tape.style.position = 'fixed';
                tape.style.width = rect.width + 'px';
                tape.classList.add('dragging');
                this.updateDragPos();
            }
        });
        
        // Also handle clicking on screen for gameplay
        if(e.target.id === 'crt-canvas') Game.handleInput(true);
    },

    move(e) {
        this.x = e.clientX;
        this.y = e.clientY;
        if(this.dragTarget) this.updateDragPos();
        
        if(!this.isDown) Game.handleMove(this.x, this.y);
    },

    up(e) {
        this.isDown = false;
        
        if(this.dragTarget) {
            // Check drop zone (VCR Slot)
            const slot = document.getElementById('slot').getBoundingClientRect();
            const tape = this.dragTarget.getBoundingClientRect();
            
            // Simple AABB collision
            if(tape.left < slot.right && tape.right > slot.left &&
               tape.top < slot.bottom && tape.bottom > slot.top) {
                // DROP!
                VCR.insert(this.dragTarget);
            } else {
                // Return to rack
                this.dragTarget.style.position = 'relative';
                this.dragTarget.style.left = '0';
                this.dragTarget.style.top = '0';
                this.dragTarget.style.transform = 'none';
            }
            
            this.dragTarget.classList.remove('dragging');
            this.dragTarget = null;
        }
    },

    updateDragPos() {
        if(!this.dragTarget) return;
        this.dragTarget.style.left = (this.x - this.dragOffset.x) + 'px';
        this.dragTarget.style.top = (this.y - this.dragOffset.y) + 'px';
        // Add physics tilt based on velocity (simplified)
        this.dragTarget.style.transform = `rotate(${Math.random()*2-1}deg) scale(1.05)`;
    }
};

// --- 4. THE VCR SYSTEM ---
const VCR = {
    state: 'idle', // idle, playing, ejected
    activeTapeId: null,
    
    insert(tapeEl) {
        if(this.state === 'playing') return;
        
        AudioEngine.playClunk();
        this.state = 'loading';
        
        // Visuals
        const slot = document.getElementById('slot');
        slot.classList.add('open');
        tapeEl.classList.add('in-machine');
        
        setTimeout(() => {
            slot.classList.remove('open');
            this.state = 'playing';
            this.activeTapeId = parseInt(tapeEl.dataset.id);
            document.getElementById('pwr-led').classList.add('on');
            Game.loadTape(this.activeTapeId);
        }, 800);
    },

    eject() {
        if(this.state !== 'playing') return;
        
        AudioEngine.playClunk();
        AudioEngine.stopMusic();
        this.state = 'idle';
        
        document.getElementById('pwr-led').classList.remove('on');
        document.getElementById('slot').classList.add('open');
        
        setTimeout(() => {
            // Bring tape back
            const tape = document.querySelector(`.tape-obj[data-id="${this.activeTapeId}"]`);
            if(tape) {
                tape.classList.remove('in-machine');
                tape.style.position = 'relative';
                tape.style.left = '0'; 
                tape.style.top = '0';
            }
            document.getElementById('slot').classList.remove('open');
            Game.stop();
            
            // Unlock Tape 4 check
            if(Game.progress.tape3) {
                document.getElementById('tape-4').style.display = 'block';
            }
            
        }, 600);
    }
};

// --- 5. RENDER & GAME ENGINE ---
const Game = {
    canvas: document.getElementById('crt-canvas'),
    ctx: document.getElementById('crt-canvas').getContext('2d'),
    width: 0, height: 0,
    raf: null,
    frame: 0,
    
    mode: 'static', // static, game
    level: null,
    
    progress: { tape1: false, tape2: false, tape3: false },
    
    init() {
        this.resize();
        window.addEventListener('resize', () => this.resize());
        this.loop();
    },

    resize() {
        const r = this.canvas.parentElement.getBoundingClientRect();
        this.canvas.width = r.width;
        this.canvas.height = r.height;
        this.width = r.width;
        this.height = r.height;
    },

    loadTape(id) {
        this.mode = 'game';
        this.frame = 0;
        
        if(id === 1) this.level = new Tape1_Hallway(this);
        if(id === 2) this.level = new Tape2_Curve(this);
        if(id === 3) this.level = new Tape3_Signal(this);
        if(id === 4) this.level = new Tape4_Finale(this);
        
        this.level.start();
    },

    stop() {
        this.mode = 'static';
        this.level = null;
    },

    handleInput(click) {
        if(this.level) this.level.input(click);
    },
    
    handleMove(x, y) {
        // Convert screen coords to canvas coords
        const r = this.canvas.getBoundingClientRect();
        const cx = x - r.left;
        const cy = y - r.top;
        if(this.level) this.level.move(cx, cy);
    },

    loop() {
        this.ctx.fillStyle = '#000';
        this.ctx.fillRect(0, 0, this.width, this.height);
        
        if(this.mode === 'static') {
            this.drawStatic();
        } else if (this.level) {
            this.level.update();
            this.level.draw(this.ctx);
            // CRT Lines
            this.ctx.fillStyle = `rgba(0, 255, 0, 0.03)`;
            this.ctx.fillRect(0, (this.frame * 2) % this.height, this.width, 2);
        }

        // Global vignette
        const grad = this.ctx.createRadialGradient(this.width/2, this.height/2, this.width/3, this.width/2, this.height/2, this.width);
        grad.addColorStop(0, 'transparent');
        grad.addColorStop(1, 'rgba(0,0,0,0.6)');
        this.ctx.fillStyle = grad;
        this.ctx.fillRect(0,0,this.width, this.height);

        this.frame++;
        requestAnimationFrame(() => this.loop());
    },

    drawStatic() {
        const img = this.ctx.createImageData(this.width, this.height);
        const buf = new Uint32Array(img.data.buffer);
        for(let i=0; i<buf.length; i++) {
            if(Math.random() < 0.1) buf[i] = 0xff111111; // Dark gray
            else buf[i] = 0xff000000;
        }
        this.ctx.putImageData(img, 0, 0);
        
        // Text
        this.ctx.font = "30px 'VT323'";
        this.ctx.fillStyle = "#1a8000";
        this.ctx.textAlign = "center";
        this.ctx.fillText("NO SIGNAL", this.width/2, this.height/2);
        
        // Time
        const d = new Date();
        this.ctx.font = "20px 'VT323'";
        this.ctx.fillText(d.toLocaleTimeString(), this.width - 60, 40);
    }
};

// --- 6. LEVEL CLASSES (5 CHAPTERS EACH) ---

class BaseLevel {
    constructor(game) {
        this.game = game;
        this.w = game.width;
        this.h = game.height;
        this.chapter = 1;
        this.timer = 0;
        this.text = "";
        this.textAlpha = 0;
    }
    showText(str, dur=180) {
        this.text = str;
        this.textAlpha = 255;
        this.textTimer = dur;
        AudioEngine.playTone(400, 'square', 0.05, 0.05);
    }
    drawUI(ctx) {
        if(this.textAlpha > 0) {
            ctx.fillStyle = `rgba(0, 0, 0, 0.8)`;
            ctx.fillRect(20, this.h - 80, this.w - 40, 60);
            
            ctx.font = "24px 'Space Mono'";
            ctx.fillStyle = `rgba(50, 255, 50, ${this.textAlpha/255})`;
            ctx.textAlign = "center";
            ctx.fillText(this.text, this.w/2, this.h - 45);
            
            this.textAlpha -= 1;
        }
        // Scanline
        ctx.fillStyle = "rgba(255,255,255,0.05)";
        ctx.fillRect(0, Math.random()*this.h, this.w, 2);
    }
}

// === TAPE 1: THE HALLWAY (Anxiety/Stealth) ===
class Tape1_Hallway extends BaseLevel {
    start() {
        this.p = { x: 50, y: this.h - 100 };
        this.eyes = [];
        this.doorX = this.w + 500;
        AudioEngine.startSoundtrack('hallway');
        this.showText("CH 1: THE WEIGHT. Move slowly.");
    }

    input(click) {}
    
    move(x, y) {
        // Mechanics: If you move mouse FAST, you slow down.
        // If you move mouse SLOW, you move fast. (Paradox)
        const dx = Math.abs(x - this.lastX || x);
        this.lastX = x;
        
        let speed = 0;
        if(dx < 5) speed = 2; // Slow movement = Fast walk
        else if (dx > 20) speed = 0.2; // Panic movement = Freeze
        
        this.p.x += speed;
    }

    update() {
        this.timer++;
        
        // Chapter Transitions
        if(this.chapter === 1 && this.p.x > 300) {
            this.chapter = 2;
            this.showText("CH 2: THE GAZE. Don't touch the eyes.");
            // Spawn Eyes
            for(let i=0; i<10; i++) this.eyes.push({x: this.w + i*200, y: 100 + Math.random()*200});
        }
        
        // Logic
        this.p.x = Math.min(this.p.x, this.w/2); // Camera lock logic simulation
        
        // Background parallax
        this.eyes.forEach(e => {
            e.x -= 2; // Moving left
            if(Math.abs(e.x - this.p.x) < 30) {
                // Collision with gaze
                AudioEngine.playTone(100, 'sawtooth', 0.1, 0.1);
                this.p.x -= 10; // Push back
            }
        });

        // End condition
        if(this.timer > 1000 && this.chapter < 5) {
             this.chapter = 5;
             this.showText("CH 5: THE DOOR. It's locked from the inside.");
             setTimeout(() => {
                 Game.progress.tape1 = true;
                 VCR.eject();
             }, 4000);
        }
    }

    draw(ctx) {
        // Hallway perspective
        ctx.fillStyle = "#111";
        ctx.fillRect(0,0,this.w,this.h);
        
        // Floor
        ctx.strokeStyle = "#333";
        ctx.beginPath();
        ctx.moveTo(0, this.h); ctx.lineTo(this.w/2, this.h/2); ctx.lineTo(this.w, this.h);
        ctx.stroke();

        // Player (Small White Dot)
        ctx.fillStyle = "#fff";
        ctx.beginPath(); ctx.arc(this.p.x, this.p.y, 5, 0, Math.PI*2); ctx.fill();
        
        // Eyes
        ctx.fillStyle = "#f00";
        this.eyes.forEach(e => {
            ctx.beginPath(); 
            // Eye shape
            ctx.ellipse(e.x, e.y, 20, 10, 0, 0, Math.PI*2);
            ctx.fill();
        });

        this.drawUI(ctx);
    }
}

// === TAPE 2: THE CURVE (Survival) ===
class Tape2_Curve extends BaseLevel {
    start() {
        this.p = { x: this.w/2, y: this.h - 50 };
        this.bullets = [];
        this.hits = 0;
        AudioEngine.startSoundtrack('panic');
        this.showText("CH 1: THE RAIN. Avoid the grades.");
    }
    
    move(x, y) { this.p.x = x; }

    update() {
        this.timer++;
        
        // Spawn Grades
        if(this.timer % 10 === 0) {
            this.bullets.push({
                x: Math.random() * this.w,
                y: -20,
                txt: Math.random()>0.5 ? "F" : "D-",
                v: 3 + Math.random() * 3
            });
        }
        
        // Update
        this.bullets.forEach((b,i) => {
            b.y += b.v;
            // Collision
            if(MathUtils.dist(b.x, b.y, this.p.x, this.p.y) < 20) {
                this.bullets.splice(i, 1);
                this.hits++;
                AudioEngine.playNoise(0.1, 'white', 0.2);
            }
        });
        
        if(this.timer > 1200) {
            this.showText(`SURVIVED. HITS: ${this.hits}. You kept standing.`);
             setTimeout(() => {
                 Game.progress.tape2 = true;
                 VCR.eject();
             }, 4000);
        }
    }

    draw(ctx) {
        // Matrix Rain style
        ctx.fillStyle = "rgba(0,0,0,0.2)";
        ctx.fillRect(0,0,this.w,this.h);
        
        ctx.font = "20px 'VT323'";
        this.bullets.forEach(b => {
            ctx.fillStyle = "#0f0";
            ctx.fillText(b.txt, b.x, b.y);
        });
        
        // Player
        ctx.fillStyle = "#fff";
        ctx.fillRect(this.p.x-10, this.p.y-10, 20, 20);
        
        this.drawUI(ctx);
    }
}

// === TAPE 3: SIGNAL LOST (Puzzle) ===
class Tape3_Signal extends BaseLevel {
    start() {
        this.noise = 1.0;
        AudioEngine.startSoundtrack('void');
        this.showText("CH 1: THE VOID. No Guide detected.");
    }
    
    input(click) {
        // Mechanic: Click to clear noise
        if(click) {
            this.noise -= 0.05;
            AudioEngine.playTone(200 + (1-this.noise)*500, 'sine', 0.1, 0.1);
        }
    }

    update() {
        this.timer++;
        // Noise grows back
        if(this.noise < 1.0) this.noise += 0.002;
        
        if(this.noise <= 0.1) {
             this.showText("SIGNAL RESTORED. I am sufficient.");
             setTimeout(() => {
                 Game.progress.tape3 = true;
                 VCR.eject();
             }, 4000);
        }
    }

    draw(ctx) {
        // Hidden Image
        ctx.fillStyle = "#000";
        ctx.fillRect(0,0,this.w,this.h);
        
        ctx.fillStyle = "#fff";
        ctx.font = "40px 'Space Mono'";
        ctx.textAlign = "center";
        ctx.fillText("I AM ENOUGH", this.w/2, this.h/2);
        
        // Noise Overlay
        const img = ctx.getImageData(0,0,this.w,this.h);
        const data = img.data;
        for(let i=0; i<data.length; i+=4) {
            if(Math.random() < this.noise) {
                data[i] = data[i+1] = data[i+2] = Math.random()*255;
            }
        }
        ctx.putImageData(img, 0, 0);
        
        this.drawUI(ctx);
    }
}

// === TAPE 4: FINALE (Cinematic) ===
class Tape4_Finale extends BaseLevel {
    start() {
        AudioEngine.startSoundtrack('hope');
        this.particles = [];
        for(let i=0; i<100; i++) this.particles.push({
            x: this.w/2, y: this.h/2,
            vx: (Math.random()-0.5)*2, vy: (Math.random()-0.5)*2,
            life: Math.random()
        });
    }

    update() {
        this.timer++;
        this.particles.forEach(p => {
            p.x += p.vx; p.y += p.vy;
            if(p.x<0||p.x>this.w) p.vx*=-1;
            if(p.y<0||p.y>this.h) p.vy*=-1;
        });
        
        if(this.timer === 100) this.showText("DADDY: Happy Birthday.");
        if(this.timer === 300) this.showText("You saved yourself.");
    }

    draw(ctx) {
        // Gold/Warm
        const g = ctx.createLinearGradient(0,0,0,this.h);
        g.addColorStop(0, "#332200");
        g.addColorStop(1, "#664400");
        ctx.fillStyle = g;
        ctx.fillRect(0,0,this.w,this.h);
        
        ctx.fillStyle = "#ffcc00";
        this.particles.forEach(p => {
            ctx.beginPath(); ctx.arc(p.x, p.y, 2, 0, Math.PI*2); ctx.fill();
        });
        
        this.drawUI(ctx);
    }
}

// --- INIT ---
function BIOS_BOOT() {
    AudioEngine.init();
    document.getElementById('bios-screen').style.display = 'none';
    Input.init();
    Game.init();
    
    // Create tapes
    const rack = document.getElementById('rack');
    const tapesData = [
        {id:1, label:"THE HALLWAY", color:"#fff"},
        {id:2, label:"THE CURVE", color:"#f00"},
        {id:3, label:"SIGNAL LOST", color:"#888"},
        {id:4, label:"RECORD", color:"gold", hidden:true}
    ];
    
    tapesData.forEach(t => {
        const div = document.createElement('div');
        div.className = 'tape-obj';
        div.dataset.id = t.id;
        if(t.hidden) { div.id = 'tape-4'; div.style.display='none'; }
        
        div.innerHTML = `
            <div class="tape-window">
                <div class="tape-spool"></div><div class="tape-spool"></div>
            </div>
            <div class="tape-label" style="background:${t.color === 'gold' ? '#ffcc00' : '#f0f0f0'}">${t.label}</div>
        `;
        rack.appendChild(div);
    });
    
    // Eject button logic
    document.getElementById('eject-btn').onclick = () => VCR.eject();
}

document.getElementById('bios-screen').onclick = BIOS_BOOT;

</script>
</body>
</html>
